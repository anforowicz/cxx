//! This test harness helps to verify that
//! the C++ code
//! generated by a successful invocations of `cxx_gen` APIs
//! results in expected error messages
//! when compiled by a C++ compiler.

use proc_macro2::TokenStream;
use std::borrow::Cow;
use std::path::{Path, PathBuf};

/// Helper for setting up a test that:
///
/// 1. Takes a `#[cxx::bridge]` and generates `.cc` and `.h` files,
/// 2. Optionally sets up other files (e.g. supplementary header files),
/// 3. Tests compiling the generated `.cc` file.
pub struct Test {
    temp_dir: tempdir::TempDir,

    /// Path to the `.cc` file (in `temp_dir`) that is generated by the
    /// `cxx_gen` crate out of the `cxx_bridge` argument passed to `Test::new`.
    generated_cc: PathBuf,
}

impl Test {
    /// Creates a new test for the given `cxx_bridge`.
    ///
    /// Example:
    ///
    /// ```rs
    /// let test = Test::new(quote!{
    ///     #[cxx::bridge]
    ///     mod ffi {
    ///         unsafe extern "C++" {
    ///             include!("include.h");
    ///             pub fn do_cpp_thing();
    ///         }
    ///     }
    /// });
    /// ```
    ///
    /// # Panics
    ///
    /// Panics if there is a failure when generating `.cc` and `.h` files from the `cxx_bridge`.
    #[must_use]
    pub fn new(cxx_bridge: TokenStream) -> Self {
        let temp_dir = tempdir::TempDir::new("cxx--cpp_ui_tests").unwrap();
        let generated_h = temp_dir.path().join("cxx_bridge.generated.h");
        let generated_cc = temp_dir.path().join("cxx_bridge.generated.cc");

        {
            let opt = cxx_gen::Opt::default();
            let generated = cxx_gen::generate_header_and_cc(cxx_bridge, &opt).unwrap();
            std::fs::write(&generated_h, &generated.header).unwrap();
            std::fs::write(&generated_cc, &generated.implementation).unwrap();
        }

        Self {
            temp_dir,
            generated_cc,
        }
    }

    /// Writes a file to the temporary test directory.
    /// The new file will be present in the `-I` include path passed to the compiler.
    ///
    /// # Panics
    ///
    /// Panics if there is an error when writing the file.
    pub fn write_file(&self, filename: impl AsRef<Path>, contents: &str) {
        std::fs::write(self.temp_dir.path().join(filename), contents).unwrap();
    }

    /// Compiles the `.cc` file generated `Self::new`.
    ///
    /// # Panics
    ///
    /// Panics if there is a problem with spawning the C++ compiler.
    /// (Compilation errors will *not* result in a panic.)
    #[must_use]
    pub fn compile(&self) -> CompilationResult {
        let mut build = cc::Build::new();
        build
            .include(self.temp_dir.path())
            .out_dir(self.temp_dir.path())
            .cpp(true);

        // Arbitrarily using `c++20` for now.  If some test cases require a specific C++ version,
        // then in the future we can make this configurable with a new field of `Test`.
        build.std("c++20");

        // Set info required by the `cc` crate.
        //
        // We assume that tests are run on the host.  This assumption is a bit icky, but works in
        // practice (and FWIW `tests/compiletest.rs` can be seen as a precedent).
        let target = include_str!(concat!(env!("OUT_DIR"), "/target_triple.txt"));
        build.opt_level(3).host(target).target(target);

        // It seems that the `cc` crate doesn't currently provide an API for getting
        // a `Command` for building a single C++ source file.  We can work around that
        // by adding `-c <file.cc>` ourselves - it seems to work for all the compilers
        // where these tests run...
        let mut command = build.get_compiler().to_command();
        command
            .stdout(std::process::Stdio::piped())
            .stderr(std::process::Stdio::piped())
            .current_dir(self.temp_dir.path())
            .arg("-c")
            .arg(&self.generated_cc);
        let output = command.spawn().unwrap().wait_with_output().unwrap();
        CompilationResult(output)
    }
}

/// Wrapper around the output from a C++ compiler.
pub struct CompilationResult(std::process::Output);

impl CompilationResult {
    fn stdout(&self) -> Cow<'_, str> {
        String::from_utf8_lossy(&self.0.stdout)
    }

    fn stderr(&self) -> Cow<'_, str> {
        String::from_utf8_lossy(&self.0.stderr)
    }

    fn dump_output_and_panic(&self, msg: &str) {
        eprintln!("{}", self.stdout());
        eprintln!("{}", self.stderr());
        panic!("{msg}");
    }

    fn error_lines(&self) -> Vec<String> {
        assert!(!self.0.status.success());

        // It seems that MSVC reports errors to stdout rather than stderr, so
        // let's just analyze all the lines - this should work for all compilers
        // exercised by the CI.
        let stdout = self.stdout();
        let stderr = self.stderr();
        let all_lines = stdout.lines().chain(stderr.lines());

        all_lines
            .filter(|line| {
                // This should match MSVC error output
                // (e.g. `file.cc(<line number>): error C2338: static_assert failed: ...`)
                // as well as Clang or GCC error output
                // (e.g. `file.cc:<line>:<column>: error: static assertion failed: ...`
                line.contains(": error")
            })
            .map(ToString::to_string)
            .collect::<Vec<_>>()
    }

    /// Asserts that the C++ compilation succeeded.
    ///
    /// # Panics
    ///
    /// Panics if the C++ compiler reported an error.
    pub fn assert_success(&self) {
        if !self.0.status.success() {
            self.dump_output_and_panic("Compiler reported an error");
        }
    }

    /// Verifies that the compilation failed with a single error, and return the
    /// stderr line describing this error.
    ///
    /// Note that different compilers may return slightly different error
    /// messages, so tests should be careful to only verify presence of some
    /// substrings.
    ///
    /// # Panics
    ///
    /// Panics if there was no error, or if there was more than a single error.
    #[must_use]
    pub fn expect_single_error(&self) -> String {
        let error_lines = self.error_lines();
        if error_lines.is_empty() {
            self.dump_output_and_panic("No error lines found, despite non-zero exit code?");
        }
        if error_lines.len() > 1 {
            self.dump_output_and_panic("Unexpectedly more than 1 error line was present");
        }

        // `eprintln` to help with debugging test failues that may happen later.
        let single_error_line = error_lines.into_iter().next().unwrap();
        eprintln!("Got single error as expected: {single_error_line}");
        single_error_line
    }
}

#[cfg(test)]
mod test {
    use super::Test;
    use quote::quote;

    #[test]
    fn test_success_smoke_test() {
        let test = Test::new(quote! {
            #[cxx::bridge]
            mod ffi {
                unsafe extern "C++" {
                    include!("include.h");
                    pub fn do_cpp_thing();
                }
            }
        });
        test.write_file("include.h", "void do_cpp_thing();");
        test.compile().assert_success();
    }

    #[test]
    fn test_failure_smoke_test() {
        let test = Test::new(quote! {
            #[cxx::bridge]
            mod ffi {
                unsafe extern "C++" {
                    include!("include.h");
                }
            }
        });
        test.write_file(
            "include.h",
            r#"
                static_assert(false, "This is a failure smoke test");
            "#,
        );
        let err_msg = test.compile().expect_single_error();
        assert!(err_msg.contains("This is a failure smoke test"));
    }

    #[test]
    #[should_panic = "Unexpectedly more than 1 error line was present"]
    fn test_failure_with_unexpected_extra_error_line() {
        let test = Test::new(quote! {
            #[cxx::bridge]
            mod ffi {
                unsafe extern "C++" {
                    include!("include.h");
                }
            }
        });
        test.write_file(
            "include.h",
            r#"
                static_assert(false, "First error line");
                static_assert(false, "Second error line");
            "#,
        );

        // We `should_panic` inside `expect_single_error` below:
        let _ = test.compile().expect_single_error();
    }
}
